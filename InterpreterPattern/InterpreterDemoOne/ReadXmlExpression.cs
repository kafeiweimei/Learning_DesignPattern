/***
*	Title："设计模式" 项目
*		主题：解释器模式
*	Description：
*	    基础概念：解释器模式的本质是【分离实现，解释执行】
*	        解释器模式通过一个解释器对象处理一个语法规则的方式，把复杂的功能分离开；然后选择需要被执行的功能，并把这些功能组合成为需要被解释执行的抽象语法树；再按照抽象语法树来解释执行，实现相应的功能。
*	            认识这个本质对于识别和变形使用解释器模式是很有作用的。从表面上看，解释器模式关注的是我们平时不太用到的自定义语法的处理；但从实质上看，解释器模式的思路仍然是分离、封装、简化，和很多模式是一样的。
*	            （比如：可以使用解释器模式模拟状态模式的功能。如果把解释器模式要处理的语法简化到只有一个状态的标记，把解释器看成是对状态的处理对象。对同一个表示状态的语法，可以有很多不同的解释器，也就是有很多不同的处理状态对象，然后在创建抽象语法树的时候，简化成根据状态的标记来创建相应的解释器，不用再构建树。这样简化下来，是不是可以用解释器模拟出状态模式的功能呢？）
*	    解释器模式的定义：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。简单的说就是【语法规则】
*	    认识解释器模式？
*	        1、解释器模式的功能：使用解释器对象来表示和处理相应的语法规则，一般一个解释器处理一条语法规则。理论上来说，只要能用解释器对象把符合语法的表达式表示出来，而且能够构成抽象的语法树，那都可以使用解释器模式来处理。
*	        2、语法规则和解释器：语法规则和解释器之间是有对应关系的，一般一个解释器处理一条语法规则，但是反过来并不成立（一条语法规则是可以有多种解释和处理的，也就是一条语法规则可以对应多个解释器对象）。
*	        3、上下文的公用性：上下文在解释器模式中起着非常重要的作用。由于上下文会被传递到所有的解释器中，因此可以在上下文中存储和访问解释器的状态（比如：前面的解释器可以存储一些数据在上下文中，后面的解释器就可以获取这些值）；
*	            另外还可以通过上下文传递一些在解释器外部，但是解释器需要的数据，也可以是一些全局的、公共的数据。
*	            上下文还有一个功能，就是可以提供所有解释器对象的公共功能，类似于对象组合，而不是使用继承来获取公共功能，在每个解释器对象中都可以调用。
*	        4、谁来构建抽象语法树？自己在客户端手工地构建语法树是很麻烦的，但是在解释器模式中，并没有涉及这部分功能，只是负责对构建好的抽象语法树进行解释处理【可以提供解析器来实现把表达式转换为抽象语法树】。
*	            还有一个问题就是一条语法规则是可以对应多个解释器对象的（也就是说同一个元素，是可以转换成多个解释器对象的，这也意味着同一个表达式，是可以构成不同的抽象语法树的，这也造成了构建抽象语法树变得很困难，且工作量非常大）。
*	        5、谁负责解释操作？只要定义好抽象语法树，肯定是解释器来负责解释执行。虽然有不同的语法规则，但是解释器不负责选择究竟用哪一个解释器对象来解释执行语法规则，选择解释器的功能在构建抽象语法树的时候就完成了。
*	    
*	    解释器模式的优点：
*	        1、易于实现语法：在解释器模式中，一条语法规则用一个解释器对象来解释执行。对于解释器的实现来讲，功能就变得比较简单（只需要考虑一条语法规则的实现就可以了，其他的都不用管）。
*	        2、易于扩展新的语法：由于采用一个解释器对象负责一条语法规则的方式，使得扩展新的语法非常容易。扩展了新的语法，只需要创建相应的解释器对象，在创建抽象语法树的时候使用这个新的解释器对象就可以了。
*	    解释器模式的缺点：
*	        1、不适合复杂的语法（如果语法特别负责，构建解释器模式需要的抽象语法树的工作是非常艰巨的，再加上有可能会需要构建多个抽象语法树。所以解释器模式不太适合于复杂的语法，对于复杂的语法，使用语法分析程序或编译器生成器可能会更好一些）。
*	    
*	    何时选用解释器模式？
*	        1、当有一个语言需要解释执行，并且可以将该语言中的句子表示为一个抽象语法树的时候，可以考虑使用解释器模式。
*	        2、在使用解释器模式的时候，还需考虑两个内容：
*	            《1》语法相对应该比较简单，太复杂的语法不适合使用解释器模式。
*	            《2》效率要求不是很高，对效率要求很高的情况下，不适合使用解释器模式。
*	        
*	    
*	             
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace InterpreterPattern.InterpreterDemoOne
{
    /// <summary>
    /// 用于处理自定义xml取值表达式的【抽象解释器】
    /// </summary>
    abstract class ReadXmlExpression
    {
        /// <summary>
        /// 解释表达式
        /// </summary>
        public abstract string[] Interpret(Context c);

    }//Class_end
}
