
/***
*	Title："设计模式" 项目
*		主题：观察者模式
*	Description：
*	    本质：观察者模式的本质【触发联动】（当修改目标对象状态的时候，就会触发相应的通知，然后会循环调用所有注册的观察者对象的相应方法）
*	    定义：定义对象间的一种一对多的依赖关系，当一个对象状态发生改变的时候，所有依赖于它的对象都得到通知并被自动更新；
*	    
*	    认识观察者模式：
*	            1、目标与观察者的关系
*	                《1》观察者模式又被称为【发布——订阅模式】；
*	                《2》目标与观察者是典型的一对多关系（注意：若观察者只有一个，也是可以的，这样就是一对一关系）；
*	                《3》观察者也可以同时观察多个目标（若观察者为多个目标定义的通知方法都是同一个的话，会带来麻烦，
*	                    因为需要接收多个目标通知，就需要区分不同的目标的通知方法；一般情况下，观察者应该为不同的目标定义不同的回调方法）
*	    
*	            2、单向依赖：
*	                    《1》观察者和目标是单向依赖的，只有观察者依赖于目标，而目标是不会依赖观察者的；
*	                    《2》它们之间的联系主动权是掌握在目标手中，只有目标知道什么时候需要通知观察者，整个过程中，观察者都是被动的，被动的等待目标通知；
*	                    《3》对目标而言，所有观察者都是一样的，目标会一视同仁的地对待【当然，也可以通过在目标中进行控制，实现有区别的对待观察者】；
*	            
*	            3、基本实现说明：
*	                    《1》具体的目标实现对象要能维护观察者的注册信息【最简单的方式就是采用一个容器列表来维护】；
*	                    《2》具体的目标实现对象需要维护引起通知的状态，一般情况下是目标自己的状态；变形情况喜爱也可以是别对的对象状态；
*	                    《3》具体的观察者对象需要能够接收目标的通知，能够接收目标传递的数据；或者能够主动地去获取目标数据，并进行后续处理；
*	                    《4》如何一个观察者观察多个目标，那么在观察者的更新方法里面，需要去判断是来自哪一个目标的通知；最简单的方法是扩展
*	                         通知方法（比如：在通知方法里面多传递一个参数来进行区分；或者直接给不同的目标定义不同的方法）
*	            
*	            4、命名建议：
*	                    《1》目标接口的定义【建议在名称后面跟Subject】；
*	                    《2》观察者接口的定义【建议在名称后面跟Observer】;
*	                    《3》观察者接口的更新方法【建议名称为update】；
*	                    
*	            5、触发通知的时机：【一般情况下，是在完成了状态维护后触发，因为通知会传递数据】（不能够先通知在修改数据，这样会
*	                                很容易出问题，导致观察者与目标者的状态不一致）；
*	            
*	            6、相互观察：在某些应用中，可能会出现目标和观察者是相互观察的情况，如下所示：
*	                    《1》实现A、B对象观察C对象；
*	                    《2》实现B、C对象观察A对象；
*	                    此时就会出现C、A对象在相互观察（即C对象的变化会引起A对象的联动操作，反之亦然；出现这种情况需要特别谨慎处理，否则会出现死循环情况）
*	            
*	            7、观察者模式调用顺序：
*	                    《1》创建目标对象；
*	                    《2》创建观察者对象；
*	                    《3》向目标对象注册观察者对象；
*	                    《4》实际运行起来（目前对象状态改变，则通知所有注册的观察者对象进行相应的处理；观察者对象回调目标对象获取相应的数据）
*	                    
*	            8、通知的顺序：从理论上来说，当目标对象的状态变化之后通知所有观察者，顺序是不确定的，因此观察者实现的功能，
*	                            绝对不能依赖通知的顺序【即：多个观察者之间的功能是平行的，相互不应该有先后的依赖关系】
*	      
*	     推模型和拉模型：在观察者模式中，分为推模型和拉模型
*	            1、推模型：目标对象主动向观察者推送目标的详细信息（不管观察者是否需要，推送的信息通常是目标对象的全部或部分数据，相当于广播通信）；
*	            2、拉模型：目标对象在通知观察者的时候，只传递少量信息（如果观察者需要更具体的详细信息，由观察者主动到目标对象中获取，
*	                        相当于观察者从目标对象中拉取数据【一般这种模型的实现中，会把目标对象自身通过update方法传递给观察者，这样在观察者需要
*	                        获取数据的时候，就可以通过这个引用来获取了】）
*	            3、两种模型的比较：
*	                    《1》推模型是假定目标对象知道观察者需要的数据；拉模型是目标对象不知道观察者具体需要什么数据，没办法只能把自身传递给观察者，让观察者按需取值；
*	                    《2》推模型可能会使得观察者对象难以复用（因为观察者定义的update方法是按需定义的，可能无法兼顾没有考虑到的情况，意味着出现新情况的时候，
*	                        就可能需要提供新的update方法，或者干脆重新实现新的观察者）；
*	                        拉模型则不会出现拉模型的情况，因为拉模型update方法的参数是目标对象本身（这基本上是目标对象能传递的最大数据集合了，基本上可以适应各种情况需要）
*	     
*	     观察者模式的优点：
*	            1、实现了观察者和目标之间的抽象耦合（即：原本目标对象在状态发生改变的时候，需要直接调用所有的观察者对象，但是抽象出
*	                观察者接口以后，目标和观察者就只在抽象层面上耦合 【也就是说：目标只知道观察者接口，而不知道具体的观察者类】从而实现
*	                目标类与具体观察者类之间的解耦）；
*	            2、观察者模式实现了动态联动（即：做一个操作会引起其他相关的操作）由于观察者模式对观察者注册实行管理，那就可以在运行期间，
*	                通过动态地控制注册的观察者，来控制某个动作的联动范文，从而实现动态联动。
*	            3、观察者模式支持广播通信（即：由于目标发送通知给观察者是面向所有注册的观察者，所以每次目标通知的信息都要对所有注册的观察者广播
*	                ，当然也可以通过目标上添加新的功能来限制广播范围）【在广播通信的时候要注意一个问题，就是广播造成死循环的问题】     
*	     
*	     观察者模式的缺点：
*	            1、可能会引起无谓的操作：（由于观察者模式每次都是广播通信，不管观察者需不需要，每个观察者都会被调用update方法，
*	                如果观察者不需要执行相应的处理，那么这次操作就浪费了；浪费了还好，最怕引起误更新，那就麻烦了）【如：本应该
*	                在执行这个状态更新前把某个观察者删除掉，这样通知的时候就没有这个观察者了；但是现在忘掉了，就会引起误操作】
*	      
*	     何时选用观察者模式：
*	            1、当一个抽象模型有两个方面（其中一个方面的操作依赖与另一个方面的状态变化）；
*	            2、如果在更改一个对象的时候，需要同时连带改变其他的对象，而且不知道究竟应该有多少对象需要被连带改变；
*	            3、当一个对象必须通知其他对象，但是你又希望这个对象和其他被它通知的对象是松散耦合的；
*	      
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ObserverPattern.Pull
{
    /// <summary>
    /// 观察者接口（比如：报纸的读者）
    /// </summary>
    internal interface IObserver
    {
        /// <summary>
        /// 主动拉取报纸信息（看是否有新的报纸内容）
        /// </summary>
        /// <param name="subject">目标对象（如：报纸）</param>
        void Pull(Subject subject);

    }//Interface_end
}
