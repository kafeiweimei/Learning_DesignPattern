/***
*	Title："设计模式" 项目
*		主题：命令模式
*	Description：
*	    基础概念：命令模式的本质是【封装请求】命令模式的关键是把请求封装成为命令对象，然后就可以对这个命令对象进行一系列的处理（如：参数化配置、可撤销操作、宏命令、队列请求、日志请求等）
*	    定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作
*	    说明：
*	        1、在命令模式中，会定义一个命令的接口，用来约束所有的命令对象，然后提供具体的命令实现，每个命令实现对象是对客户端某个请求的封装。
*	        2、在命令模式中，命令对象并不知道如何处理命令，会有相应的接收者对象来真正执行命令
*	    
*	    认识命令模式：
*	        1、命令模式的关键：
*	            命令模式的关键之处就是【把请求封装成为对象】（即：命令对象，并定义了统一的执行操作接口）
*	        2、命令模式的组装和调用：
*	            在命令模式中经常会有一个命令的组装者，用它来维护命令的“虚”实现和真实实现之间的关系（如果是超级智能的命令【即：命令对象
*	            自己完全实现好了，不需要接收者】那就是命令模式的退回，不需要接收者，自然也就不需要组装者了）
*	            真正的用户就是具体化请求的内容，然后提交请求进行触发就可以了（真正的用户会通过Invoker来触发命令）【在实际开发过程中，Client和Invoker
*	            可以融合在一起，由客户在使用命令模式的时候，先进行命令对象和接收者的组装，组装完成后，就可以调用命令执行请求了】
*	        3、命令模式的接收者
*	            接收者可以是任意的类，对它没有什么特殊要求，这个对象知道如何真正执行命令的操作，执行时是从Command的实现类里面转调过来。
*	            一个接收者对象可以处理多个命令，接收者和命令之间没有约定的对应关系（接收者提供的方法个数、名称、功能和命令中的可以不一样，
*	            只要能够通过调用接受者的方法来实现命令的功能就可以了）
*	        4、智能命令
*	            在标准的命令模式里面，命令的实现类是没有真正实现命令要求的功能的【真正执行命令的功能是接收者】；
*	            如果命令的实现对象比较智能，它自己就能真正地实现命令要求的功能，不再需要调用接收者，这种情况就称为智能命令；
*	            也可以有半智能的命令，命令对象知道部分实现，其他的还是需要调用接收者来完成
*	        5、发起请求的对象和真正实现的对象是解耦的（请求究竟是谁处理？如何处理？发起请求的对象是不知道的【即：发起请求的对象和真正
*	            实现的对象是解耦的】发起请求的对象只管发出命令，其他的就不管了） 
*	        6、命令模式的调用过程（分为两个阶段：一阶段是组装命令对象和接收者对象；二阶段则是触发调用Invoker，来让命令真正执行）
*	    
*	    命令模式的优点：
*	        1、更松散的耦合：命令模式使得发起命令的对象（客户端）和具体实现命令的对象（接收者）完全解耦【即：
*	            发起命令的对象完全不知道具体实现对象是谁，也不知道如何实现】
*	        2、更动态的控制：命令模式把请求封装起来，可以动态地对它进行参数化、队列化和日志化等操作，使得系统更加灵活
*	        3、很自然的复合命令：命令模式中的命令对象能够很容易地组合为复合命令（如宏命令）从而使得系统操作简单，功能更强大
*	        4、更好的扩展性：由于发起命令的对象和具体的实现完全解耦，因此扩展新命令就很容易，只需要实现新的命令对象，然后在
*	           装配的时候，把具体的实现对象设置到命对象中，然后可以使用这个命令对象，已有的实现完全不用变化 
*	    
*	    何时选用命令模式：
*	        1、需要抽象出需要执行的动作，并参数化这些对象，可选用命令模式；
*	        2、需要再不同的时刻指定、排列和执行请求，可选用命令模式；
*	        3、需要支持取消操作，可选用命令模式；
*	        4、需支持当系统崩溃时，能将系统的操作功能重新执行一遍，可选用命令模式；
*	        5、需要事物的系统中（如数据库事务），可选用命令模式
*	    
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CommandPattern
{
    /// <summary>
    ///开机命令的实现类
    ///拥有真正开机命令的实现（通过调用接受者的方法来实现命令）
    /// </summary>
    internal class OpenCommand : ICommand
    {
        //持有真正实现命令的接受者——主板对象
        private IMainBoard mainBoard = null;

        /// <summary>
        /// 构造函数
        /// </summary>
        /// <param name="mainBoard">主板对象</param>
        public OpenCommand(IMainBoard mainBoard)
        {
            this.mainBoard = mainBoard;
                
        }

        public void Execute()
        {
            //对于命令对象，根本不知道如何开机，会调用主板对象，让主板对象完成开机功能
            this.mainBoard.Open();
        }
    }//Class_end
}
