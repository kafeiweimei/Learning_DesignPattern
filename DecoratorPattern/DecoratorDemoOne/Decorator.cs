/***
*	Title："设计模式" 项目
*		主题：装饰模式
*	Description：
*	    基础概念：装饰模式的本质是【动态组合】
*	        动态是手段，组合才是目的。这里的组合有两个含义：一个是动态功能的组合（即动态进行装饰器的组合）；另外一个是指对象组合（通过对象组合来实现为被装饰对象透明地增加功能）。
*	        需要注意：装饰模式不仅可以增加功能，而且也可以控制功能的访问，完全实现新的功能，还可以控制装饰的功能是在被装饰功能之前还是之后来运行等。
*	        总之，装饰模式是通过把复杂功能简单化、分散化，然后在运行期间，根据需要来动态组合的这样一个模式。
*	        
*	    装饰模式的定义：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式比生成子类更为灵活。
*	    认识装饰模式：
*	        《1》装饰模式的功能：装饰模式能够实现动态地为对象添加功能，是从一个对象外部来给对象增加功能，相当于是改变了对象的外观。
*	            当装饰过后，从外部使用系统的角度看，就不再是使用原始的那个对象了，而是使用被一系列的装饰器装饰过后的对象。这样就能够灵活地改变一个对象的功能，只要动态组合的装饰器发生了改变，那么最终所得到的对象功能也就发生了改变。
*	            变相地还得到了另外一个好处，就是装饰器功能的复用，可以给一个对象多次增加同一个装饰器，也可以用同一个装饰器装饰不同的对象。
*	        《2》对象组合：一个类功能的扩展方式【可以是继承】【也可以是功能更强大、更灵活的对象组合方式】。现在在面向对象的设计中，有一条基本规则就是【尽量使用对象组合】，而不是对象继承来扩展和复用功能。
*	        《3》装饰器：装饰器实现了对被装饰对象的某些装饰功能，可以在装饰器中调用被装饰对象的功能，获取相应的值，这其实是一种递归调用。在装饰器中不仅仅是可以给被装饰对象增加功能，还可以根据需要选择是否调用被装饰对象的功能，如果不调用被装饰对象的功能，那就变成完成重新实现，相当于动态修改了被装饰对象的功能。
*	            各个装饰器中间最好是完全独立的功能，不要有依赖，这样在进行装饰组合的时候，才没有先后顺序的限制（即：先装饰谁和后装饰谁都应该是一样的）否则会极大降低装饰器组合的灵活性。
*	        《4》装饰器和组件类的关系：装饰器是用来装饰组件的，装饰器一定要实现和组件类一致的接口，保证它们是同一个类型，并具有同一个外观，这样组合完成的装饰才能够递归调用下去。
*	            组件类是不知道装饰器的存在的，装饰器为组件添加功能是一种透明的包装，组件类毫不知情。需要改变的是外部使用组件类的地方，现在需要使用包装后的类，接口是一样的，但是具体的实现类发生了改变。
*	        《5》退化形式：如果仅仅只是想要添加一个功能，就没有必要再设计装饰器的抽象类了，直接在装饰器中实现跟组件一样的接口，然后实现相应的装饰功能就可以了。但是建议最好还是设计上装饰器的抽象类，这样有利于程序的扩展。    
*	    
*	    装饰模式的优点：
*	        《1》比继承更灵活：从为对象添加功能的角度来看，装饰模式比继承更加灵活。继承是静态的，而且一旦继承所有子类都有一样的功能。而装饰模式采用把功能分离到每个装饰器当中，然后通过对象组合的方式，在运行时动态地组合功能，每个被装饰的对象最终有哪些功能，是由运行期动态组合的功能来决定的。
*	        《2》更容易复用功能：装饰模式把一系列复杂的功能分散到每个装饰器当中，一般一个装饰器只实现一个功能，使实现装饰器变得简单，更重要的是这样有利于装饰器功能的复用，可以给一个对象增加多个同样的装饰器，也可以把一个装饰器用来装饰不同的对象，从而实现复用装饰器的功能。
*	        《3》简化高层定义：装饰模式可以通过组合装饰器的方式，为对象增添任意多的功能。因此在进行高层定义的时候，不用把所有的功能都定义出来，而是定义最基本的就可以了， 可以在需要使用的时候，组合相应的装饰器来完成所需的功能。
*	    装饰模式的缺点：会产生很多细粒度对象（即装饰模式是把一系列复杂的功能，分散到每个装饰器当中，一般一个装饰器只实现一个功能，这样就会产生很多细粒度对象，且功能越复杂，需要的细粒度对象越多）。
*	    
*	    何时选用装饰模式？
*	        《1》如果需要在不影响其他对象的情况下，以动态、透明的方式给对象添加职责，可以使用装饰模式，这计划就是装饰模式的主要功能。
*	        《2》如果不适合使用子类来进程扩展的时候，可以使用装饰模式（因为装饰模式是使用的“对象组合”方式，所谓不适合用子类扩展的方式：如扩展功能需要的子类太多，造成子类数目呈爆炸性增长）。
*	    
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace DecoratorPattern.DecoratorDemoOne
{
    internal class Decorator : PrizeRule
    {
        //被装饰的对象
        protected PrizeRule prizeRule;

        /// <summary>
        /// 构造函数
        /// </summary>
        /// <param name="prizeRule">被装饰的对象</param>
        public Decorator(PrizeRule prizeRule)
        {
            this.prizeRule = prizeRule;
        }

        public override double CaculatePrize(string user, DateTime start, DateTime end)
        {
            //转调被装饰对象的方法
            return prizeRule.CaculatePrize(user,start,end);
        }

    }//Class_end
}
