/***
*	Title："设计模式" 项目
*		主题：组合模式
*	Description：
*	    基础概念：组合模式的本质是【统一叶子对象和组合对象】
*	    
*	    组合模式的定义：将对象组合成树型结构以表示“部分-整体”的层次结构；组合模式使得用户对单个对象和组合对象的使用具有一致性
*	     
*	    认识组合模式： 
*	        1、组合模式的目的：让客户端不再区分操作的是组合对象还是叶子对象，而是以一个统一的方式来操作；
*	            实现这个目标的关键之处就是：设计一个抽象的组件类，让它可以代表组合对象和叶子对象，这样一来，客户端就不用区分到底是
*	            组合对象还是叶子对象了，只需要把它们全部当作组件对象进行统一的操作就可以了
*	        
*	        2、对象树：通常，组合模式会组合出树型结构来，组成这个树型结构所使用的多个组件对象就自然的形成了对象树。这也意味着，
*	            所有可以使用对象树来描述或操作的功能，都可以考虑使用组合模式【如：读取XML文件，或是对语句进行语法解析】
*	    
*	        3、组合模式中的递归：指的是对象递归组合【是对象本身的递归，是对象组合的方式，从设计上来说是递归关联，是对象关系的一种；
*	            且理论上没有层次限制】，不是常说的递归算法。通常我们谈论的递归算法是指“一个方法会调用方法自己”这样的算法（如：经典的求阶乘）在
*	        
*	        4、Component中是否应该实现一个Component列表：大多数情况下，一个Composite对象会持有子节点的集合【那么能不能把这个子节点集合定义
*	            到Component中去呢？这样一来，大部分的工作就可以在Component中完成了】（事实上，这种方法不太好，因为在父类中存放子类的实例对象
*	            ，对于Composite节点是没有影响，因为它本来就需要存放子节点；但是对于叶子节点来说，就会导致空间的浪费，因为叶子节点本身不需要子节点；
*	            只有当组合结构中叶子对象数目较少的时候，才会使用这种方法）
*	        
*	        5、最大化Component定义：由于组合模式的目的是让客户端不再区分操作的是组合对象还是叶子对象，而是以一种统一的方式来操作；
*	            所以Component中的方法也主要是两种对象对外方法的和【即组件里面既有叶子对象需要的方法，也有组合对象需要的方法】（但是这种
*	            实现是与类的设计原则冲突的，类的设计原则是【一个父类应该只定义那些对它的子类有意义的操作】，那怎么解决这个冲突呢？）
*	            常见的做法是：在Component中为对某些子对象没有意义的方法提供默认的实现，或是默认抛出不支持该功能的例外（这样的话，如果子
*	            对象需要这个功能，那就覆盖实现它，如果不需要，那就不用管，使用父类的默认实现就可以了）
*	            从一个层面来说，如果把叶子对象看成是一个特殊的Composite对象，这样对于Component而言，子对象就全部看做是组合对象，因此定义的所有方法都是有意义的
*	        
*	        6、子部件排序：在某些应用中，使用组合模式的时候，需要按照一定的顺序来使用子组件对象（如：进行语法分析的时候，使用组合模式构建的抽象语法树
*	            ，在解析执行的时候，是需要按照顺序来执行的）对于这样的功能，在设计的时候，需要把组件对象的索引考虑进去，并仔细地设计对子节点的访问和管理接口
*	            。通常的方式是需要按照顺序来存储，这样在获取的时候就可以按照顺序得到了，可以考虑结合迭代器模式来实现按照顺序访问组件对象
*	        
*	    安全性和透明性：
*	        1、在组合模式的层次结构中，到底在哪一些类里面定义这些管理子组件的操作？是应该在Component中声明这些操作呢？还是Composite中声明这些操作呢？【在不同的实现中，进行安全性和透明性的权衡选择】
*	            《1》安全性是指：从客户使用组合模式上看是否更安全，如果安全，那么就不会有误操作的可能，能访问的方法都是被支持的功能；
*	            《2》透明性是指：从客户使用组合模式上，是否需要区分到底是组合对象还是叶子对象，如果透明，那就不用再区分，对于客户而言都是组件对象
*	                具体的类型对于客户而言是透明的，客户无须关心。
*	                
*	             1、安全性的实现：如果把管理子组件的操作定义在Composite中，那么客户在使用叶子对象的时候，就不会发生使用添加子组件或是删除子组件的操作了，
*	                因为压根就没有这样的功能，这样的实现是安全的。但是这样一来，客户端在使用的时候，就必须区分到底是Composite对象，还是叶子对象，不同对象的功能是不一样的（
*	                这种实现方式，对客户而言就不是透明的了）。
*	                
*	             2、透明性的实现：如果把管理子组件的操作定义在Component中，那么客户端只需要面对Component，而无须关系具体的组件类型，这就是透明的实现。
*	                但是透明是的实现是以安全性为代价的，因为在Component中定义的一些方法，对于叶子对象来说是没有意义的（如增加、删除子组件对象）而客户不知道这些区别，
*	                对客户是透明的，因此客户可能会对叶子对象调用这种增加或删除子组件的方法，这样的操作是不安全的。
*	                
*	             3、两种实现方式的选择：对于组合模式而言，在安全性和透明性上，会更看重透明性，毕竟组合模式的功能就是要让用户对叶子对象和组合对象的使用具有一致性。
*	                而且对于安全性的实现，需要区分是组合对象还是叶子对象。有时候，需要将对象进行类型转换，却发现类型信息丢失了，只好强行转换，
*	                这种类型转换必然是不够安全的【对于这种情况的处理方法是：在Component中定义一个GetComposite方法，用来判断是组合对象还是叶子对象，
*	                如果是组合对象，就返回组合对象，如果是叶子对象，就返回null，这样就实现了先判断，再强制转换】。
*	                因此在使用组合模式的时候，建议多采用透明性的实现方式，少用安全性模式。
*	                
*	     组合模式的优点：
*	        1、定义了包含基本对象和组合对象的类层次结构（在组合模式中，基本对象可以被组合成为复杂的组合对象，而组合对象又可以组合
*	            成为更复杂的组合对象，可以不断递归下去，从而构成一个统一的组合对象类层次结构）
*	        2、统一了组合对象和叶子对象（在组合模式中，可以把叶子对象当作特殊的组合对象看待，为它们定义统一的父类，从而把组合对象和叶子对象的行为统一起来）
*	        3、简化了客户端的调用（组合模式通过统一组合对象和叶子对象，使得客户端在使用它们的时候，不需要再去区分它们，客户不关心使用的
*	            到底是什么类型的对象，这就大大简化了客户端的使用）
*	        4、更容易扩展（由于客户端是统一的面对Component来操作，因此，新定义的Composite或Leaf子类就能够很容易地与已有的结构一起工作，
*	            而客户端不需要为增添了新的组件类而改变）
*	    
*	     组合模式的缺点：很难限制组合中的组件类型
*	    
*	     何时选用组合模式：
*	        1、如果你想表示对象的部分-整体层次结构，可以选用组合模式，把整体和部分的操作统一起来，使得层次结构实现更加简单，才能够外部来使用这个层次结构也容易；
*	        2、如果你希望统一地使用组合结构中的所有对象，可以选用组合模式，这正是组合模式提供的主要功能
*	    
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace CompositePattern.CompositeDemo
{
    /// <summary>
    /// 抽象的组件对象
    /// </summary>
    internal abstract class Component
    {
        //输出组件自身的名称
        public abstract void PrintStruct(string preStr);

        //向组合对象中加入组件对象
        public abstract void Add(Component child);

        //从组合对象中移除某个组件对象
        public abstract void Remove(Component child);

        //返回某个索引对应的组件对象
        public abstract Component GetComponent(int index);

    }//Class_end
}
