/***
*	Title："设计模式" 项目
*		主题：备忘录模式
*	Description：
*	    基础概念：备忘录模式的本质是【保存和恢复内部状态】
*	        《1》保存是手段，恢复才是目的；
*	            标准的备忘录模式保存数据的手段是通过内存缓存；广义的备忘录模式实现的时候，可以采用离线存储的方式，把这些数据保存到文件或者数据库等地方。
*	        《2》备忘录模式备忘些什么内容呢？
*	            备忘的就是原发器对象的内部状态，这些内部状态是不对外的，只有原发器对象才能够进行操作；
*	        《3》备忘录模式为什么要保存数据呢？
*	            目的是为了在有需要的时候，恢复原发器对象的内部状态，所以恢复才是备忘录模式的目的。
*	         对于备忘录模式最主要的一个特点【封装状态的备忘录对象】不应该被除了原发器对象之外的对象访问，至于如何存储都是小事；
*	         备忘录模式要解决的主要问题是【在不破坏对象封装性的前提下，来保存和恢复对象的内部状态】这是一个很主要的判断依据。
*	        
*	    备忘录模式的定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可以将该对象恢复到原先保存的状态了
*	    
*	    认识备忘录模式：
*	        1、备忘录模式的功能：在不破坏封装性的前提下，捕获一个对象的内部状态，这里有两点要注意：
*	            《1》一个是不破坏封装性（即：对象不能暴露它不应该暴露的细节）；
*	            《2》另一个是捕获的对象的内部状态（且通常还是运行期间某个时候对象的内部状态）
*	            为什么要捕获这个对象内部状态呢？捕获这个内部状态有什么用？
*	            《1》是为了在以后的某个时候，将该对象的状态恢复到备忘录所保存的状态，这才是备忘录真正的目的；
*	            捕获的状态存放在哪里呢？
*	            在备忘录模式中，捕获的内部状态存储在备忘录对象中；而备忘录对象通常会被存储在原发器对象之外（即：被保存状态对象的外部）通常是放在管理者对象那里。
*	        2、备忘录对象：就是用来记录原发起需要保存的状态对象（简单点的实现就是封装数据的对象）
*	           备忘录对象和普通的封装数据对象是有区别的：
*	           《1》备忘录对象一般只让原发器对象来操作（为了保证这一点，通常备忘录对象作为原发器对象的内部类来实现，且实现为私有，这样就断绝了外部来访问这个备忘录对象的途径）；
*	                备忘录对象需要保存在原发器对象之外，为了与外部交互，通常备忘录对象都会实现一个窄接口来标识对象类型。
*	           《2》普通封装的数据对象是谁都可以使用；
*	        3、原发器对象：就是需要被保存状态的对象，也有可能需要恢复状态的对象（原发器对象一般会包含备忘录对象的实现）。
*	            通常原发器对象应该提供捕获某个时刻对象内部状态的方法，在这个方法中，原发器对象会创建备忘录对象，把需要保存的状态数据设置到备忘录对象中，然后把备忘录对象提供给管理者对象来保存；
*	            当然，原发器对象也应该提供这样的方法（按照外部要求来恢复内部状态到某个备忘录对象记录的状态）。
*	        4、管理者对象：主要是负责保存备忘录对象：
*	            《1》并不一定要特别的做出一个管理者对象来（广义地说，调用原发器获得备忘录对象后，备忘录对象放在哪里，哪个对象就可以算是管理者对象）；
*	            《2》管理者对象并不是只能管理一个备忘录对象，一个管理者对象可以管理很多的备忘录对象。
*	            《3》狭义的管理者对象是只管理同一类的备忘录对象，但广义的管理者对象是可以管理不同类型的备忘录对象的。
*	            《4》管理者对象需要实现的基本功能主要是：存入备忘录对象、保存备忘录对象和获取备忘录对象（从功能上看，就是一个缓存功能的实现，或者是一个简单的对象实例池的实现）。
*	            《5》管理者虽然能存取备忘录对象，但是不能访问备忘录对象内部的数据。
*	        5、窄接口和宽接口：在备忘录模式中，为了控制备忘录对象的访问，出现了窄接口和宽接口的概念：
*	            《1》窄接口：管理者只能看到备忘录的窄接口，窄接口的实现中通常没有任何的方法，只是一个类型标识。窄接口使得管理者只能将备忘录传递给其他对象。
*	            《2》宽接口：原发器能够看到一个宽接口，允许它访问所需的所有数据，来返回到先前的状态（理想情况是：只允许生成备忘录的原发器来访问该备忘录的内部状态，通常实现成为原发器内的一个私有内部类）
*	                即：我们的备忘录模式一示例中：定义了【IFlowAMockMemo】接口，里面没有定义任何方法，然后让备忘录来实现这个接口，从而标识备忘录就是这么一个IFlowAMockMemo的类型，这个接口就是窄接口；
*	                备忘录对象是实现在原发器内的一个私有内部类，只有原发器对象可以访问它，原发器可以访问到备忘录对象中所有的内部状态，这就是宽接口。
*	            这是备忘录模式的标准实现方式（即：窄接口没有任何方法，把备忘录对象实现成为原发器对象的私有内部类） 
*	             
*	             能否在窄接口中提供备忘录对象对外的方法？变相提供一个宽点的接口呢？
*	                通常情况是不会这么做的（因为这样一来，所有能拿到这个接口的对象就可以通过这个接口来访问备忘录内部的数据或功能，这违反了备忘录模式的初衷【备忘录模式要求“在不破坏封装性”的前提下】如果这么做，那就
*	                等于是暴露了内部细节。因此，备忘录模式在实现的时候，对外多是采用窄接口，而且通常不会定义任何方法）。       
*	        6、使用备忘录模式潜在的代价：标准的备忘录模式的实现机制是依靠缓存来实现的，因此，当需要备忘录的数据量较大时，或者是存储的备忘录对象数据量不大但是数量很多的时候，或者是用户很频繁地创建备忘录对象时，这些都会导致非常大的内存开销。
*	            因此在使用备忘录模式的时候，一定要好好思考应用的环境，如果使用的代价太高，就不要选择备忘录模式，可以采用其他替代方案。
*	        7、增量存储：如果需要频繁地创建备忘录对象，而且创建和应用备忘录对象来恢复状态的顺序是可控的，那么可以让备忘录进行增量存储，也就是备忘录可以仅仅存储原发器内部相对于上一次存储状态后的增量改变。
*	            （如：在命令模式实现可撤销命令的实现中，就可以使用备忘录来保存每个命令对象的状态，然后在撤销命令的时候，使用备忘录来恢复这些状态。由于命令的历史列表是按照命令操作的顺序来存放的，也是按照这个历史列表来进行取消和重做的，因此顺序是可控的，
*	            那么这种情况，还可以让备忘录对象只存储一个命令所产生的增量改变而不是它所影响的每一个对象的完整状态）。
*	    
*	    备忘录模式的优点：
*	        《1》更好的封装性：通过使用备忘录对象，来封装原发器对象的内部状态，虽然这个对象是保存在原发器对象的外部，但是由于备忘录对象的窄接口并不提供任何方法，这样有效保证了对原发器对象内部状态的封装，不把原发器对象的内部实现细节暴露给外部。
*	        《2》简化了原发器：备忘录对象被保存到原发器对象之外，让客户来管理他们的请求状态，从而让原发器对象得到简化。
*	        《3》窄接口和宽接口：引入窄接口和宽接口，使得不同的地方，对备忘录对象的访问是不一样的。窄接口保证了只有原发器才可以访问备忘录对象的状态。
*	        
*	    备忘录模式的缺点：
*	        《1》可能会导致高开销：备忘录模式基本的功能就是备忘录对象的存储和恢复，它的基本实现方式就是缓存备忘录对象。这样一来，如果需要缓存的数量很大，或者是特别频繁地创建备忘录对象，开销是很大的。
*	     
*	    何时选用备忘录模式？
*	        《1》如果必须保存一个对象在某一个时刻的全部或者部分状态，方便在以后需要的时候，可以把该对象恢复到先前的状态，可以使用备忘录模式【使用备忘录对象来封装和保存需要保存的内部状态，然后把备忘录对象保存到管理者对象中，在需要的时候，再从管理者对象中获取备忘录对象，来恢复对象的状态】。
*	        《2》如果需要保存一个对象的内部状态，但是如果用接口来让其他对象直接得到这些需要保存的状态，将会暴露对象的实现细节并破坏对象的封装性，这时可以使用备忘录模式【把备忘录对象实现细节成为原发器对象的内部类，而且还是私有，从而保证了只有原发器对象才能访问该备忘录对象；这样即保存了需要保存的状态，又不会暴露内部实现细节】。
*	        
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace MemoPattern.MemoDemoOne
{
    /// <summary>
    /// 备忘录的窄接口（没有任何方法定义）
    /// </summary>
    internal interface IFlowAMockMemo
    {

    }//Interface_end
}
