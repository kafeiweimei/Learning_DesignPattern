/***
*	Title："设计模式" 项目
*		主题：享元模式
*	Description：
*	    基础概念：享元模式的本质是【分离与共享】
*	        1、【分离】的是对象状态中变与不变的部分；【共享】的是对象中不变的部分；享元模式的关键就在于【分离变与不变】把不变的部分作为享元对象的内部状态，而变化部分则作为外部状态，由外部来维护，这样享元对象就能够被共享，从而减少对象数量，并节省大量的内存空间。
*	        2、在使用享元模式时，需要考虑【哪些状态需要分离？如何分离？分离后如何处理？哪些需要共享？如果管理共享的对象？外部如何使用共享的享元对象？是否需要不共享的对象？等】
*	        
*	    享元模式的定义：运用共享技术有效地支持大量细粒度的对象。
*	    享元模式的结构说明：
*	        《1》享元接口：通过这个IFlyWeight接口可以接收并作用于外部状态（即：通过这个接口传入外部状态，在享元对象的方法处理中可能会使用这些外部的数据）。
*	        《2》具体的享元对象：具体的享元对象必须是可共享的，需要封装IFlyweight接口的内部状态。
*	        《3》非共享的享元实现对象：非共享的享元实现对象通常是对共享享元对象的组合对象。
*	        《4》享元工厂：主要是用来创建并管理共享的享元对象，并对外提供访问共享享元的接口。
*	        《5》享元客户端：主要工作是维持一个对IFlyweight的引用，计算或存储享元对象的外部状态（可以访问共享和不共享的IFlyweight对象）
*	    
*	    认识享元模式：
*	        《1》变与不变：享元模式设计的重点【在于分离变与不变】。把一个对象的状态分成【内部状态】和【外部状态】，内部状态是不变的，外部状态是可变的。然后通过共享不变的部分，达到减少对象数量并节约内存的目的。
*	            在享元对象需要的时候，可以从外部传入外部状态给共享的对象，共享对象会在功能处理的时候，使用自己内部的状态和这些外部的状态。
*	            事实上，分离变与不变是软件设计的最基本方式之一（如：预留接口）为什么在这个地方预留接口，一个常见的原因就是这里存在变化，可能在今后需要扩展或者是改变已有的实现，因此预留接口作为“可插入性的保证”。
*	        《2》共享与不共享：在享元模式中，享元对象又有共享和不共享之分；不共享的情况通常出现在与组合模式合用的情况，通常共享的是叶子对象，一般不共享的部分是由共享部分组合而成的（由于所有细粒度的叶子对象都已经缓存了，
*	            那么缓存组合对象就没有什么意义了）。
*	        《3》内部状态和外部状态：
*	            1、享元模式的内部状态通常指包含在享元对象内部的、对象本身的状态，是独立于使用享元的场景信息，一般创建后就不再变化的状态，因此可以共享。
*	            2、享元模式的外部状态通常指享元对象之外的状态，取决于使用享元的场景，会根据使用场景而变化，因此不可共享。如果享元对象需要这些外部状态的话，可以从外部传递到享元对象中（如：通过方法的参数来传递）。
*	            也就是说：享元模式真正缓存和共享的数据是享元的内部状态，而外部状态是不应该被缓存共享的。享元的【内部状态】和【外部状态】是独立的，外部状态的变化不应该影响到内部状态。
*	        《4》实例池：在享元模式中，为了创建和管理共享的享元部分，引入了享元的工厂。享元工厂中一般都包含有享元对象的实例池，享元对象就是缓存在这个实例池中的。
*	            所谓的实例池（指的是缓存和管理对象实例的程序，通常实例池会提供对象实例的运行环境，并控制对象实例的生命周期）。
*	            工业级的实例池在实现上有两个最基本的难点：一个是动态控制实例数量，另一个是动态分配实例来提供给外部使用；这些都是需要算法来做保证的。
*	        《5》谁来初始化共享对象：在享元模式中，通常是在第一次向享元工厂请求获取共享对象的时候，进行共享对象的初始化，而且多半都是在享元工厂内部实现，不会从外部传入共享对象。
*	            当然也可以从外部传入一些创建共享对象所需的值，享元工厂可以按照这些值去初始化需要共享的对象，然后把创建好的共享对象的实例放入享元工厂内部的缓存中，以后再请求这个共享对象的时候就不用再创建了。
*	            
*	    享元模式的优点：
*	        《1》减少对象数量，节省内存空间：
*	           1、可能有的朋友会认为共享对象会浪费空间，但是如果这些对象频繁使用，那么其实是节省空间的（因为占用空的的大小等于每个对象实例占用的大小再乘以数量，对于享元对象来讲，基本上就只有一个实例，大大减少了享元对象的数量，并节省了不少的内存空间）。
*	           2、节省空间取决于两个因素：一个是【共享而减少的实例数量】，另一个是【每个实例本身所占用的空间】（假如：每个实例对象本身占用2个字节，如果不共享数量是100个，而共享后就只有一个，那么节省的空间约等于(100-1)*2个字节）
*	    享元模式的缺点：
*	        《1》维护共享对象，需要额外开销：在维护共享对象的时候，如果功能复杂，会有很多额外的开销（如：需要创建一个线程来维护垃圾回收）
*	    
*	    何时选用享元模式？
*	        《1》如果一个应用程序使用了大量的细粒度对象，可以使用享元模式来减少对象数量。
*	        《2》如果由于使用大量的对象，造成很大的存储开销，可以使用享元模式来减少对象数量，并节约内存。
*	        《3》如果对象的大多数状态都可以转变为外部状态（如：通过计算得到、从外部传入等）可以使用享元模式来实现内部状态和外部状态的分离。
*	        《4》如果不考虑对象的外部状态，可以用相对较少的共享对象取代很多组合对象，可以使用享元模式来共享对象，然后组合对象来使用这些共享对象。
*	        
*	    
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace FlyweightPattern.FlyweightDemoOne
{
    /// <summary>
    /// 享元接口【通过这个接口可以接受并作用于外部状态】
    /// </summary>
    internal interface IFlyweight
    {
        /// <summary>
        /// 判断传入的安全实体和权限是否与享元对象内部状态匹配
        /// </summary>
        /// <param name="securityEntity">安全实体</param>
        /// <param name="permit">权限</param>
        /// <returns>true：表示匹配</returns>
        bool Math(string securityEntity,string permit);

    }//Interface_end
}
