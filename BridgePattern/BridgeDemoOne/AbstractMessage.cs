/***
*	Title："设计模式" 项目
*		主题：桥接模式
*	Description：
*	    基础概念：桥接模式的本质是【分离抽象和实现】
*	    桥接模式的定义：将抽象部分与它的实现部分分离，使它们都可以独立地变化    
*	    认识桥接模式：
*	        1、什么是桥接：通俗点说就是在不同的东西之间搭一个桥，让它们能够连接起来，可以相互通讯和使用。在桥接模式中是给什么东西搭桥呢？【是为被分离了的抽象部分和实现部分来搭桥】
*	            注意：在桥接模式中桥接是单向的，也就是只能是抽象部分的对象去使用具体实现部分的对象，而不能反过来，这就是单向桥。
*	        2、为何需要桥接：为了达到让抽象部分和实现部分都可以独立变化的目的，在桥接模式中，是把抽象部分和实现部分分离开来。
*	            虽然从程序结构上是分开了，但是抽象部分实现的时候，还是需要使用具体的实现，这可怎么办？【抽象部分如何才能调用到具体实现部分的功能呢？】搭个桥就可以了，让抽象部分通过这个桥就可以调用到实现部分的功能了，因此需要桥接。
*	        3、如何桥接：只要让抽象部分拥有实现部分的接口对象，就桥接上了，在抽象部分即可通过这个接口来调用具体实现部分的功能（即：桥接在程序上体现了在抽象部分拥有实现部分的接口对象，维护桥接就是维护这个关系）。
*	        4、独立变化：桥接模式的意图是使得抽象和实现可以独立变化，都可以分别扩充。也就是说抽象部分和实现部分是一种非常松散的关系。从某个角度来讲，抽象部分和实现部分是可以完全分开的，独立的，抽象部分不过是一个使用实现部分对外接口的程序罢了。
*	            如果这么看桥接模式的话，就类似于策略模式了。抽象部分需要根据某个策略，来选择真实的实现，也就是说桥接模式的抽象部分相当于策略模式的上下文，更原始的就直接类似于面向接口编程，通过接口分离的两个部分而已。但是别忘了，桥接模式的抽象部分，是可以继续扩展和变化的，而策略模式只有上下文，是不存在所谓抽象部分的。
*	            抽象和实现为什么还要组合在一起呢？原因是在抽象部分和实现部分还是存在内部联系的，抽象部分的实现通常是需要调用实现部分的功能来实现的。
*	        5、动态变换功能：由于桥接模式中的抽象部分和实现部分是完全分离的，因此可以在运行时动态组合具体的真实实现，从而达到动态变换功能的目的。
*	            从另外一个角度看，抽象部分和实现部分没有固定的绑定关系，因此同一个真实实现可以被不同的抽象对象使用；反过来，同一个抽象也可以有多个不同的实现。
*	        6、退化的桥接模式：如果接口仅有一个实现，那么就没有必要创建接口了，这是一种桥接模式退化的情况（即：抽象类和接口是一对一的关系，虽然如此，但还是要保持它们的分离状态，这样，它们才不会相互影响，才可以分别扩展）
*	        7、桥接模式和继承：继承是扩展对象功能的一种常见手段，通常情况下，继承扩展的功能变化纬度都是一纬的，也就是变化的因素只有一类。
*	            对于出现变化因素有两类：也就是有两个变化纬度的情况，继承实现就会比较痛苦。从理论上来说，如果用继承的方式来实现这种有两个变化纬度的情况，最后实际的实现类应该是两个维度上可变数量的乘积那么多个。如果要在任何一个纬度上进行扩展，都需要实现另外一个纬度上的可变数量那么多个实现类，这也是为何会感觉扩展起来很困难；且随着程序规模的加大，会越来越难以扩展和维护。
*	            【桥接模式】就是用来解决这种有两个变化纬度的情况下，如果灵活地扩展功能的一个很好的方案，其实，桥接模式主要是把继承改成了使用对象组合，从而把两个维度分开，让每一个纬度单独去变化，最后通过对象组合的方式，把两个维度组合起来，每一种组合的方式就相当于原来继承中的一种实现，这样就有效地减少了实际实现的类的个数【理论上，如果使用桥接模式的方式来实现这种有两种变化纬度的情况，最后实际的实现类应该是两个纬度上可变数量的和】。
*	            
*	    谁来桥接：即谁来负责创建抽象部分和实现部分的关系，大致有如下几种实现方式：
*	        1、由客户端来负责创建接口对象，并在创建抽象类对象的时候，把它设置到抽象部分的对象中去。
*	        2、可以在抽象部分对象构建的时候，由抽象部分的对象自己来创建相应的接口对象，也可以给它传递一些参数，根据参数来选择并创建具体的接口对象。
*	        3、可以在抽象类中选择并创建一个默认的接口对象，然后子类可以根据需要改变这个实现。
*	        4、也可以使用抽象工厂或者简单工厂来选择并创建具体的接口对象，抽象部分的类可以通过调用工厂的方法来获取接口对象。
*	        5、如果使用IOC/DI容器的话，还可以通过IOC/DI容器来创建具体的接口对象，并注入会到抽象类中。
*	    
*	    桥接模式的优点：
*	        1、分离抽象和实现部分：桥接模式分离了抽象部分和实现部分，从而及大地提高了系统的灵活性。让抽象部分和实现部分独立开来，分别定义接口，这有助于对系统进行分层，从而产生更好的结构化的系统。对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了。
*	        2、更好的扩展性：由于桥接模式把抽象部分和实现部分分离开了，而且分别定义接口，这就使得抽象部分和实现部分可以分别独立地扩展，而不会相互影响，从而大大提高了系统的可扩展性。
*	        3、可动态地切换实现：由于桥接模式把抽象部分和实现部分分离开了，所以在实现桥接的时候，就可以实现动态的选择和使用具体的实现。也就是说一个实现不再是固定的绑定在一个抽象接口上了，可以实现在运行期间动态地切换。
*	        4、可以减少子类的个数：对于两个变化纬度的情况，如果采用继承的实现方式，大约需要在两个纬度上的可变化数量的乘积个子类；而采用桥接模式来实现，大约需要两个纬度上的可变化数量的和个子类。可以明显的减少子类的个数。
*	    
*	    思考桥接模式：
*	        1、桥接模式的本质是：分离抽象和实现；桥接模式最重要的工作就是分离抽象部分和实现部分，这是解决问题的关键。只有把抽象部分和实现部分分离开了，才能够让它们独立地变化；只有抽象部分和实现部分可以独立地变化，系统才会有更好的可扩展性和可维护性（还有其他好处如：可以动态地切换实现、可以减少子类个数等）。
*	        2、对设计原则的体现：
*	            《1》桥接模式很好地实现了开闭原则（通常应用桥接模式的地方，抽象部分和实现部分都是可变化的，也就是应用会有两个变化纬度，桥接模式就是找到这两个变化，并分别封装起来，从而合理地实现OCP）。
*	            在使用桥接模式的时候，通常情况下，顶层的抽象类和接口是不变的，而继承抽象类的具体类是可变的。由于抽象类是通过接口来操作具体的实现类，因此具体的实现类是可以扩展的，并根据需要可以有多个具体的实现。
*	            《2》桥接模式还很好地体现了：多用对象组合，少用对象继承（如果使用继承来扩展功能，不但让对象之间有很强的耦合性，而且会需要很多的子类才能够完成相应的功能，需要两个纬度上的可变化数量的乘积个子类。而采用对象的组合，松散了对象之间的耦合性，不但使每个对象变得简单和可维护，还极大减少了子类的个数，大约要两个纬度上可变化数量的和个子类）
*	    
*	    何时选用桥接模式：
*	        1、如果不希望在抽象部分和实现部分采用固定的绑定关系，可以采用桥接模式，来把抽象部分和实现部分分开，然后在程序运行期间来动态地设置抽象部分需要用到的具体的实现，还可以动态地切换具体的实现。
*	        2、如果出现抽象部分和实现部分都能够扩展的情况，可以采用桥接模式，让抽象部分和实现部分独立地变化，从而灵活地进行单独扩展，而不是搅在一起，扩展一边会影响到另一边。
*	        3、如果希望实现部分的修改不会对客户产生影响，可以采用桥接模式。由于客户是面向抽象的接口在运行，实现部分的修改可以独立于抽象部分，并不会对客户产生影响，也可以说对客户是透明的。
*	        4、如果采用继承的方案，会导致产生很多子类，对于这种情况，可以考虑采用桥接模式，分析功能变化的原因，看看能否分离不同的纬度，然后通过桥接模式来分离它们，从而减少子类的数目。
*	        
*	    
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace BridgePattern.BridgeDemoOne
{
    /// <summary>
    /// 抽象的消息对象
    /// </summary>
    internal class AbstractMessage
    {
        //持有一个实现消息的对象
        protected IMessage message;

        /// <summary>
        /// 构造函数
        /// </summary>
        /// <param name="message">实现消息的对象</param>
        public AbstractMessage(IMessage message)
        {
            this.message = message;
        }

        /// <summary>
        /// 发送消息
        /// </summary>
        /// <param name="message">需要发送的消息内容</param>
        /// <param name="toUser">消息发送的给的人员</param>
        public virtual void SendMsg(string message,string toUser)
        {
            this.message.Send(message, toUser);
        }

    }//Class_end
}
