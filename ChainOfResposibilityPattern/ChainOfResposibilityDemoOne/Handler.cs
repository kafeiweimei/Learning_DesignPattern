/***
*	Title："设计模式" 项目
*		主题：职责链模式
*	Description：
*	    基础概念：职责链模式的本质是【分离职责，动态组合】
*	    分离职责是前提，只有先把复杂的功能分开，拆分成很多的步骤和小的功能处理，然后才能合理规划和定义职责类。可以有很多的职责类来负责处理某一个功能，让每个职责类负责处理功能的某一个方面，在运行期间进行动态组合，形成一个处理的链，把这个链运行完，功能也就处理完了。
*	    动态组合才是职责链模式的精华所在，因为要实现请求对象和处理对象的解耦，请求对象不知道谁才是真正的处理对象，因此要动态地把可能得处理对象组合起来。由于组合的方式是动态的，这就意味着可以很方便地修改和添加新的处理对象，从而让系统更加灵活和具有更好的扩展性。
*	    这么做还有一个潜在的优点：就是可以增强职责功能的复用性，如果职责功能是很多地方都可以使用的公共功能，那么它可以在很多职责链中复用。
*	    
*	    职责链模式的定义：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
*	    认识职责链模式：
*	        《1》职责链模式的功能：职责链模式主要用来处理“客户端发出一个请求，让多个对象都有机会来处理这一个请求，但是客户端不知道究竟谁会来处理他的请求”这样的情况。也就是需要让请求者和接收者解耦。这样就可以动态地切换和组合接收者了。
*	            【注意：在标准的职责链模式中，只要有对象处理了请求，这个请求就到此为止，不再被传递和处理了】
*	            如果要变形使用职责链，就可以让这个请求继续传递，每个职责对象对这个请求进行一定的功能处理，从而形成一个处理请求的功能链。
*	        《2》隐式接收者：当客户端发出请求的时候，客户端并不知道谁会真正处理他的请求，客户端只知道它提交的第一个对象。从第一个处理对象开始，整个职责链中的对象，要么自己处理请求，要么继续转发给下一个接收者。
*	            也就是对于请求而言，并不知道最终的接收者是谁，但是一般情况相爱，总是会有一个对象来处理的，因此称为隐式接收者。
*	        《3》如何构建链：职责链的链怎么构建呢？实现的方式有很多，归结起来大致有如下一些方式
*	            1-首先按照实现的地方来说：
*	                ①可以实现在客户端提交请求前组合链。也就是在使用的时候动态组合链，称为外部链。
*	                ②也可以在Handler里面实现链的组合，算是内部链的一种。
*	                ③当然还有一种就是在各个职责对象中，由各个职责对象自行决定后续的处理对象。这种实现方式要求每个职责对象除了进行业务处理外，还必须了解真个业务流程。
*	            2-按照构建链的数据来源（也就决定了按照什么顺序来组合链的数据）
*	                ①一种是在程序中动态组合。
*	                ②也可以通过外部（如：数据库来获取组合的数据，这种属于数据库驱动的方式）。
*	                ③还有一种方式就是通过配置文件传递进来，也可以是流程的配置文件。
*	           如果是从外部获取数据来构建链，那么在程序运行的时候，会读取这些数据，然后根据数据的要求来获取相应的对象，并组合起来。
*	           还有一种是不需要构建链，因为已有的对象已经自然构建成链了，这种情况多出现在组合模式构建的对象树中，这样子对象可以很自然地向上找到自己的父对象。
*	           就像部门人员的组织结构一样，顶层是总经理，总经理下面是各个部门经理，部门经理下面是项目经理，项目经理下面是各个普通员工，自然就形成：普通员工-->项目经理-->部门经理-->总经理这样的链。
*	        《4》谁来处理：职责链中那么多对象，到底谁来处理请求呢？这个是在运行时期动态决定的。当请求被传递到某个处理对象的时候，这个对象会按照已经设定好的条件来判断是否属于自己处理的范围，如果是就处理，如果不是就转发请求给下一个对象。    
*	        《5》请求一定会被处理吗？在职责链模式中，请求不一定会被处理，因为可能没有合适的处理者，请求在职责链中从头传递到尾，每个处理对象都判断不属于自己处理，最后请求就没有对象来处理。这一点是需要注意的。
*	            可以在职责链的末端始终加上一个不支持此功能处理的职责对象，这样如果传递到这里，就会出现提示，本职责链没有对象处理这个请求。
*	          
*	    功能链：在实际开发中，经常会遇到把职责链稍稍变形的用法【在标准的职责链中，一个请求在职责链中传递，只要有一个对象处理了这个请求，就会停止】。现在稍稍变通一下，改成一个请求在职责链中传递，每个职责对象负责处理请求某一个方面的功能，处理完成后，不是停止，而是继续向下传递请求，
*	        当请求通过很多职责对象处理后，功能也就完成了，这样的职责链称为功能链。
*	    
*	    职责链模式的优点：
*	        《1》请求者和接收者松散耦合：在职责链模式中，请求者并不知道接收者是谁，也不知道具体如何处理，请求者只是负责向职责链发出请求就可以了。而每个职责对象也不用管请求者或者是其他的职责对象，只负责处理自己的部分，其他的就交给其他的职责对象去处理。也就是说，请求者和接收者是完全解耦的。
*	        《2》动态组合职责：职责链模式会把功能处理分散到单独的职责对象中，然后在使用的时候，可以动态组合职责形成职责链，从而可以灵活地给对象分配职责，也可以灵活地实现金和改变对象的职责。
*	    职责链模式的缺点：
*	        《1》产生很多细粒度对象：职责链模式会把功能处理分散到单独的职责对象中，也就是每个职责对象只处理一个方面的功能，要把整个业务处理完，需要很多职责对象的组合，这样会产生大量的细粒度职责对象。
*	        《2》不一定能被处理：职责链模式的每个职责对象只负责自己处理的那一部分，因此可能会出现某个请求，把整个链传递完了，都没有职责对象处理它。这就需要在使用职责链模式的时候，需要提供默认的处理，并且注意构建的链的有效性。
*	    
*	    何时选用职责链模式？
*	        《1》如果有很多对象可以处理同一个请求，但是具体由哪个对象来处理该请求，是运行时刻动态确定的。这种情况可以使用职责链模式，把处理请求的对象实现成为职责对象，然后把它们构成一个职责链，当请求在这个链中传递的时候，具体由哪个职责对象来处理，会在运行时动态判断。
*	        《2》如果你想在不明确指定接收者的情况下，向多个对象中的其中一个提交请求的话，可以使用职责链模式。职责链模式实现了请求者和接收者之间的解耦，请求者不需要知道究竟是哪一个接收者对象来处理了请求。
*	        《3》如果想要动态指定处理一个请求的对象集合，可以使用职责链模式。职责链模式能动态地构建职责链，也就是动态地来决定到底那些职责对象来参与到处理请求中来，相当于是动态地指定了处理一个请求的职责对象集合。
*	        
*	    
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ChainOfResposibilityPattern.ChainOfResposibilityDemoOne
{
    /// <summary>
    /// 职责对象接口
    /// </summary>
    abstract internal class Handler
    {
        /// <summary>
        /// 持有下一个处理请求的对象
        /// </summary>
        public Handler Successor { get; set; }

        /// <summary>
        /// 费用申请
        /// </summary>
        /// <param name="user">申请人</param>
        /// <param name="fee">申请的费用</param>
        /// <returns>返回申请结果</returns>
        public abstract string HandleRequest(string user,double fee);

    }//Class_end
}
