/***
*	Title："设计模式" 项目
*		主题：状态模式
*	Description：
*	    基础概念：状态模式的本质是【根据状态来分离和选择行为】
*	    状态模式的定义：允许一个对象在其内部状态改变时改变它的行为；对象看起来似乎修改了它的类
*	    认识状态模式：
*	        1、状态和行为：通常指的是对象实例的属性的值；而行为指的就是对象的功能（具体的说行为大多对应到方法上）；
*	            状态模式的功能【分离状态行为，通过维护状态的变化，来调用不同状态对应的不同功能】（即：状态和行为是相关联的，它们的关系可以描述为：状态决定行为）；
*	            由于状态是在运行期间被改变的，因此行为也会在运行期间根据状态的改变而改变；看起来同一个对象，在不同的运行时刻，行为是不一样的，就像是类被修改了一样。
*	        2、行为的平行性：指的是【各个状态的行为所处的层次是一样的，相互独立的，没有关联的，是根据不同的状态决定到底走平行线的哪一条】行为是不同的，当然对应的实现也是不同的，相互之间不可以替换。
*	            平等性强调的时可替换性，大家是同一行为的不同描述或实现；因此在同一个行为发生的时候，可以根据条件挑选任意一个实现来进行相应的处理。
*	            【大家可能会发现状态模式的结构和策略模式的结构完全一样，但是，它们的目的、实现、本质却是完全不一样的。还有行为之间的特性也是状态模式和策略模式一个很重要的区别，
*	            状态模式的行为是平行性的，不可相互替换的。二策略模式的行为是平等性的，是可以相互替换的】
*	        3、上下文和状态处理对象：在状态模式中，上下文是持有状态的对象，但是上下文自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。在具体的状态处理类中经常需要获取上下文自身
*	            的数据，甚至在必要的时候会回调上下文的方法，因此，通常将上下文自身当做一个参数传递给具体的状态处理类。客户端一般只和上下文交互。客户端可以用状态对象来配置一个上下文，一旦配置完毕，就不再需要和状态对象打交道了。
*	            客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。
*	        4、不完美的开放封闭原则（OCP，Open Closed Principle）体验：比如我们现在拓展了正常投票状态给正常投票的用户给予积分奖励；但是怎么让VoteManager使用这个新的实现类呢？按照目前的实现，只能去修改VoteManager这个类的Vote方法。
*	            这样一来虽然实现了我们的功能，但是并没有完全遵守OCP原则（其实在我们实际设计开发的时候，设计原则是指导，但是并不一定要完全遵守，完全遵守设计原则几乎是不可能完成的任务）
*	        5、创建和销毁状态对象：在使用状态模式的时候，需要考虑究竟何时创建和销毁状态对象？通常有如下三种方式：
*	            《1》当需要使用状态对象的时候创建，使用完成后就销毁它们；
*	            《2》提前创建它们并且始终不销毁；
*	            《3》采用延迟加载和缓存合用的方式，就是当第一次需要使用状态对象的时候创建，使用完成后并不销毁对象，而是把这个对象缓存起来，等待下一次使用，而在合适的时候，会由缓存框架销毁状态对象。
*	            如何选择呢？
*	            《1》如果要进入的状态在运行时是不可知的，而且上下文是比较稳定的，不会经常改变状态，且使用不频繁，就采用第一种方式；
*	            《2》如果状态改变很频繁（即需要频繁的创建状态对象）且状态对象还存储着大量数据信息，则建议使用第二种方式；
*	            《3》如果无法确定状态改变是否频繁，而且有些状态对象的状态数据量大，有些较小，一切都是未知的，建议使用第三种方式。
*	            实际上，在开发过程中，第三种方式是首选的（因为它兼顾了前两种方式的优点且又避免了它们的缺点，几乎可以适应各种情况需要）【只是这个方案在实现的时候，
*	            需要实现一个合理的缓存框架，而且需要考虑多线程并发的问题，因为需要由缓存框架来在合适的时候销毁状态对象，因此实现上难度稍大】
*	         
*	        6、状态的维护和转换控制：状态的维护指【维护状态的数据，给状态设置不同的状态值】；状态转换指【根据状态的变化来选择不同的状态处理对象】。在状态模式中，通常由两个地方可以进行状态的维护和转换控制：
*	            《1》在上下文中：因为状态本身通常被实现为上下文对象的状态，因此可以在上下文中进行状态维护，当然也可以控制状态的转换了。
*	            《2》在状态的处理类中：当每个状态处理对象处理完自身状态所对应的功能后，可以根据需要指定后继的状态，以便应用能正确处理后续的请求。
*	            那么到底如何选择这两种方式呢？
*	            《1》如果状态转换的规则是一定的，一般不需要进行什么扩展规则，适合在上下文中统一进行状态的维护。
*	            《2》如果状态的转换取决于前一个状态动态处理的结果（或者是依赖于外部的数据）为了增加灵活性，此时在状态处理类中进行状态的维护。
*	        
*	        7、状态模式的优点：
*	            《1》简化应用逻辑控制：状态模式使用单独的类来封装一个状态的处理。如果把一个大的程序控制分为很多小块，每块定义一个状态来代表，那么就可以把这些逻辑控制的代码分散到很多单独的类中去，这样就把着眼点从执行状态提高到整个对象状态，
*	                使得代码结构化和意图更清晰，从而简化应用的逻辑控制。对于依赖于状态的if-else，理论上来讲，也可以改变成应用状态模式来实现，把每个if或else块定义一个状态来代表，那么就可以把块内的功能代码移动到状态处理类中，从而减少if-else，避免出现巨大的条件语句
*	            《2》更好的分离状态和行为：状态模式通过设置所有状态类的公共接口，把状态和状态对应的行为分离开，把所有与一个特定的状态相关的行为都放入到一个对象中，使得程序在控制的时候，只需要关心状态的切换，而不用关心这个状态对应的真正处理。
*	            《3》更好的扩展性：引入了状态处理的公共接口后，使得扩展新的状态变得非常容易，只需要新增加一个实现状态处理的公共接口的实现类，然后在进行状态维护的地方，设置状态编号到这个新的状态即可。
*	            《4》显示化进行状态转换：状态模式引入独立对象，使得状态的转换变得更加明确，而且状态对象可以保证上下文不会发生内部状态不一致的情况，因为上下文中只有一个变量来记录状态对象，只要为这一个变量赋值就可以了。
*	        
*	        8、状态模式的缺点：
*	            《1》一个状态对应一个状态处理类，会使得程序引入太多的状态类，使程序变得杂乱。
*	            
*	        9、何时选用状态模式？
*	            《1》如果一个对象的行为取决于它的状态，而且必须在运行时刻根据状态来改变它的行为，可以使用状态模式，来把状态和行为分离开。虽然分离开了，但状态和行为是有对应关系的，可以在运行期间，通过改变状态，就能够调用到该状态对应的状态处理对象上去，从而改变对象的行为。
*	            《2》如果一个操作中含有庞大的多分支语句，而且这些分支依赖于该对象的状态，可以使用状态模式，把各个分支的处理分散包装到单独的对象处理类中，这样，这些分支对应的对象就可以不依赖于其他对象而独立变化了。
*	         
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace StatePattern.StateDemoOne
{
    /// <summary>
    /// 投票状态接口
    /// </summary>
    internal interface IVoteState
    {
        //处理状态对象的行为
        void Vote(string user,string voteItem,VoteManager voteManager);

    }//Interface_end
}
