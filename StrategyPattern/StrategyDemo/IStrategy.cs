/***
*	Title："设计模式" 项目
*		主题：策略模式
*	Description：
*	    基础概念：策略模式的本质是【分离算法，选择实现】
*	    策略模式的定义：定义一系列的算法，把它们一个个封装起来，并且使他们可以相互替换。本模式使得算法可独立于使用它的客户而变化
*	    
*	    策略模式的上下文（context）和策略（Strategy）关系：通常上下文使用具体的策略实现对象。反过来，策略实现对象也可以从上下文
*	        获取所需的数据。因此可以将上下文当做参数传递给策略实现对象，这种情况下上下文和策略实现对象是紧密耦合的（这种情况下，上下文
*	        封装着具体策略对象进行算法运算所需要的数据，具体策略对象通过回调上下文方法来获取这些数据）。
*	        某些情况下，策略实现对象还可以回调上下文的方法来实现一定的功能，这种使用场景，上下文变相充当了多个策略算法实现的公共接口。在
*	        上下文定义的方法可以当做是所有或者是部分策略算法使用的公共功能。
*	    请注意：由于所有的策略实现对象都实现同一个策略接口，传入同一个上下文，可能会造成传入的上下文数据的浪费，因为有的算法会使用这些数据，
*	    而有的算法不会使用，但是上下文和策略对象之间交互的开销是存在的。
*	    
*	    认识策略模式：
*	        1、策略模式的功能：把具体的算法实现从具体的业务处理中独立出来，把它们实现成为单独的算法类，从而形成一系列的算法，并且让这些算法可以相互替换。
*	            【策略模式的重心不是如何来实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性】。
*	        2、策略模式和if-else语句：每个策略算法具体实现的功能，就是原来在if-else结构中的具体实现（其实多个if-elseif语句表达的就是一个平等的功能结构，你要么执行
*	            if，要么执行else或者elseif,从运行地位上来说它们都是平等的）策略模式就是把各个平等的具体实现封装到单独的策略实现类，然后通过上下文与具体的策略类进行交互。因此多个if-else语句就可以考虑使用策略模式。
*	        3、算法的平等性：策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正式因为这个平等性，才能实现算法之间的相互替换。
*	            所有的策略算法在实现杀昂也是相互独立的，相互之间没有依赖。【即：策略算法是相同行为的不同实现】
*	        4、谁来选择具体的策略算法：在策略模式中可以在两个地方进行具体策略的选择：
*	            《1》在客户端，当使用上下文的时候，由客户端来选择具体的策略算法；然后把这个策略算法设置给上下文。
*	            《2》客户端不管，由上下文来选择具体的策略算法。
*	        5、策略（strategy）的实现方式：一般情况下策略都是使用接口来定义的；但是如果多个算法具有公共功能的话，可以把策略实现为抽象类，
*	            然后把多个算法的功能功能实现到策略中。
*	        6、运行时策略的唯一性：运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。
*	        7、增加新的策略：新建一个类策略算法类继承策略接口或模板来实现新的要求，然后在客户端使用时指定新的策略算法类就可以了。
*	        
*	        
*	    策略模式的优点：
*	        1、定义一系列的算法：定义一系列的算法，实现让这些算法可以相互替换【所以会为这一系列算法定一个公共的接口
*	            ，以约束一系列算法要实现的功能。如果这一系列的算法具有公共功能，可以把策略接口实现为抽象类，把这些公共功能
*	            实现到父类中】
*	        2、避免多重条件语句：策略模式的一系列策略算法是平等的，可以互换，写在一起就是通过【if else】结构或【Switch】来组织，
*	            如果此时具体的算法实现中又有条件语句，就构成了多重条件语句，使用策略模式可以避免这样的多种条件语句。
*	        3、更好的扩展性：在策略模式中扩展新的策略非常容易，只要增加新的策略实现类，然后在使用策略的地方使用这个新的策略实现就可以了。
*	        
*	    策略模式的缺点：
*	        1、客户必须了解每种策略的不同：如：让客户端来选择具体使用哪一种策略，这就需要客户了解所有的策略，还要了解各种策略的功能和不同，
*	            这样才能做出正确的选择，而且这也暴露了策略的具体实现。
*	        2、增加了对象数目：由于策略模式把每个具体的策略实现都单独封装成为了类，如果备选的策略很多，那么对象的数目就会很可观。
*	        3、只适合扁平的算法结构：策略模式的一系列算法地位是平等的，是可以相互替换的；事实上构成了一个扁平的算法结构，也就是在一个策略接口下，
*	            有很多平等的策略算法，就相当于兄弟算法，而且运行时刻只有一个算法被使用，这就限制了算法使用的层级，使用的时候不能嵌套使用。对于
*	            需要嵌套使用多个算法的情况（如：折上折、折后返券等业务的实现），需要组合或是嵌套使用多个算法的情况，可以考虑使用装饰模式，或是变形
*	            的职责链，或是AOP等方式来实现。
*	            
*	    何时选用策略模式：
*	        1、出现有许多相关的类，仅仅是行为有差别的情况下，可以使用策略模式来使用多个行为中的一个来配置一个类的方法，实现算法的动态切换。
*	        2、出现同一个算法，有很多不同实现的情况下，可以使用策略模式把这些“不同的实现”实现成为一个算法的类层次。
*	        3、需要封装算法中，有与算法相关数据的情况下，可以使用策略模式来避免暴露这些跟算法相关的数据结构。
*	        4、出现抽象一个定义了很多行为的类，并且是通过多个if-else语句来选择这些行为的情况下，可以使用策略模式来代替这些条件语句。
*	        
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace StrategyPattern.StrategyDemo
{
    /// <summary>
    /// 策略，定义计算报价算法的接口
    /// </summary>
    internal interface IStrategy
    {
        /// <summary>
        /// 计算应报的价格
        /// </summary>
        /// <param name="goodsPrice">商品的价格（原价）</param>
        /// <returns></returns>
        double CaculatePrice(double goodsPrice);

    }//Interface_end
}
