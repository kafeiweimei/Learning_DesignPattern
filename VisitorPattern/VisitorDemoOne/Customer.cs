/***
*	Title："设计模式" 项目
*		主题：访问者模式
*	Description：
*	    基础概念：访问者模式的本质是【预留后路，回调实现】
*	    访问者模式的定义：表示一个作用于某个对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。
*	    认识访问者模式：
*	        1-访问者的功能：访问者模式能给一系列对象透明地添加新功能，从而避免在维护期间对这一系列对象进行修改，而且还能变相实现复用访问者所具有的功能。
*	            由于是针对一系列对象的操作，这也导致，如果只想给一系列对象中的部分对象添加功能，就会有些麻烦；而且要始终能保证把这一系列对象都调用到，不管是循环，还是递归，总之要让每个对象都要被访问到。
*	        2-调用通路：访问者之所以能实现【为一系列对象透明地添加新功能】注意是透明的，也就是这一系列对象是不知道被添加功能的。
*	            重要的就是依靠通用方法，访问者这边说要去访问，就提供一个访问的方法（如visit方法）；而对象那边说，好的，我接受你的访问，提供一个接受访问的方法（如accept方法）。这两个方法并不代表任何具体的功能，只是构成一个调用的通路，那么真正的功能实现在哪里呢？又如何调用到呢？
*	            很简单，就是在accept方法里面，回调visit方法，从而回调访问者的具体实现上，而这个访问者的具体实现的方法才是要添加的新的功能。
*	        3-两次分发技术：访问者模式能够实现在不改变对象结构的情况下，就可以给对象结构中的类增加功能，实现这个效果所使用的核心技术就是两次分发的技术。
*	            在访问者模式中，当客户端调用ObjectStructure的时候，会遍历ObjectStructure中所有的元素，调用这些元素的accept方法，让这些元素来接受访问，这是请求的第一次分发；在具体的元素对象中实现accept方法的时候，会回调访问者的visit方法，等于请求第二次分发了，请求被分发给访问者来进行处理，真正实现功能的正是访问者的visit方法。
*	            两次分发技术使得客户端的请求不再被静态地绑定在元素对象上，这个时候真正执行什么样的功能同时取决于访问者类型和元素类型，就算是同一种元素类型，只要访问者的类型不一样，最终执行的功能也会不一样，这样一来，就可以在元素对象不变的情况下，通过改变访问者的类型来改变真正执行的功能。
*	            两次分发技术还有一个优点，就是可以在程序运行期间进行动态的功能组装和切换，只需要在客户端调用时，组合使用不同的访问者对象实例即可。
*	        4-为何不在Component中实现回调visit方法
*	            为什么不把回调访问者方法的调用语句放到父类中去，这样不就可以复用了吗？这是不可以的，虽然看起来是相似的语句，但其实是不同的，主要的玄机就是在传入的this身上。this是代表当前的对象实例，在企业客户对象中传递的时企业客户对象的实例，在个人客户对象中传递的是个人客户对象实例，这样在访问者的实现中，可以通过不同的对象实例来访问不同的实例对象的数据，
*	            如果把这句话放到父类中，那么传递的就是父类对象的实例，是没有子对象的数据的，因此不能放到父类中去。
*	            
*	        5-空的访问方法：并不是所有的访问方法都需要实现，由于访问者模式默认的是访问对象结构中的所有元素，因此在实现某些功能的时候，如果不需要涉及某些元素的访问方法，那么这些方法可以实现为空的（如：这个访问者只想处理组合对象，那么访问叶子对象的方法就可以为空，尽管还需要访问所有的元素对象）。
*	            还有一种就是有条件接受访问，在自己的accept方法中进行判断，满足要求的则接受，不满足要求的相当于空的方法方法，什么都不做。
*	    
*	    访问者模式的优点：
*	        1-好的扩展性：能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
*	        2-好的复用性：可以通过访问者来定义整个对象结构通用的功能，从而提供复用程度。
*	        3-分离无关行为：可以通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。
*	    访问者模式的缺点：
*	        1-对象结构变化很困难：不适用于对象结构中的类经常变化的情况，因为对象结构发生了改变，访问者的接口和访问者的实现都要发生相应的改变，代价太高。
*	        2-破坏封装：访问者模式通常需要对象结构开放内部数据给访问者和ObjectStructure，这破坏了对象的封装性。
*	        
*	    思考访问者模式：
*	        1-访问者模式的本质：预留通路，回调实现。
*	            仔细思考访问者模式，它的实现主要是通过预先定义好调用的通路，在被访问的对象上定义accept方法，在访问者的对象上定义visit方法；然后在调用真正发生的时候，通过两次分发技术，利用预先定义好的通路，回调到访问者具体的实现上。
*	            明白了访问者模式的本质，就可以在定义一些通用功能，或者涉及工具类的时候让访问者派上大用场。你可以把已经实现好的一些功能作为已有的对象结构，因为在今后可能会根据实际需要为它增加新的功能，甚至希望开放接口来让其他开发人员扩展这些功能，所以你可以用访问者模式来设计，
*	            在这个对象结构上预留好通用的调用通路，在以后添加功能，或者其他开发人员来扩展的时候，只需要提供新的访问者实现，就能够很好地加入到系统中来了。
*	       
*	    何时选用访问者模式？
*	        1-如果想对一个对象接口实施一些依赖于对象结构中具体类的操作，可以使用访问者模式。
*	        2-如果想对一个对象结构中的各个元素进行很多不同的而且不相关得操作，为了避免这些操作使得类变得杂乱，可以使用访问者模式。把这些操作分散到不同的访问者对象中去，每个访问者对象实现同一类功能。
*	        3-如果对象结构很少变动，但是需要经常给对象结构中的元素对象定义新的操作，可以使用访问者模式。
*	            
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace VisitorPattern.VisitorDemoOne
{
    /// <summary>
    /// 各种客户的父类
    /// </summary>
    abstract internal class Customer
    {
        /// <summary>
        /// 客户的编号
        /// </summary>
        public string CustomerId { get; set; }=string.Empty;

        /// <summary>
        /// 客户名称
        /// </summary>
        public string CustomerName { get; set; } = string.Empty;

        /// <summary>
        /// 接受访问者的访问
        /// </summary>
        /// <param name="visitor">访问者</param>
        public abstract void Accept(IVisitor visitor);


    }//Class_end
}
