/***
*	Title："设计模式" 项目
*		主题：外观模式
*	Description：
*	    基础概念：本质是【封装交互、简化调用】
*	        外观模式：就是通过引入一个外观类，在这个类里面定义客户端想要的简单方法，
*	                  然后在这些方法里面实现；由外观类再去分别调用内部的多个模块来实现功能，
*	                  从而让客户端变得简单；这样一来，客户端就只需要和外观类交互就可以了。
*	                  
*	        外观模式目的：为了让外部减少与子系统内部多个对象或模块的交互，松散耦合，封装了内部细节，
*	                      从而让外部能够更简单地使用子系统
*	                      
*	        使用外观模式的注意点：因为外观模式是当做子系统对外的通道，虽然也可以在这里定义一些子系统
*	                              没有的功能，但不建议这样做【外观应该是包装已有功能，它主要负责组合已有
*	                              功能来实现客户需要,本身并不进行功能的处理，而不是添加新的实现】
*	                              
*	        外观模式的实现：对一个子系统来说，外观类不需要很多，可以实现为一个单例
*	                        或直接将外观类中的方法实现为静态方法，将外观类作为一个辅助工具类，方便外部直接调用                      
*	                              
*	        有外观模式，但可以不使用：虽然有外观类，但如果有需要，外部还是可以绕开外观类，而直接调用
*	                                  某个具体模块功能，这样就能实现兼顾组合功能和细节功能
*	                                  
*		    外观模式优点：
*		                松散耦合（松散了客户端与子系统的耦合关系，让子系统内部模块更容易扩展与维护）
*		                简单易用（外观类让子系统更加易用，客户端不再需要了解子系统内部实现，也不需要与子系统内部模块交互）
*		                更好的划分访问层次（合理使用外观类，可以帮助我们更好地划分访问层次【外观类把需暴露给外部的功能都集中提供，而子系统内部更多的方法是内部使用】）
*		    外观模式缺点：过多或不太合理的外观类容易让人迷惑（即是调用外观类好，还是直接调用模块好）
*		    
*		    何时选用外观模式？
*		                1、希望为一个复杂的子系统提供简单的对外通道，简化外部调用；
*		                2、想要让外部程序和抽象类的实现部分松散耦合（使用外观类将子系统与外部客户端分离开，提供子系统的独立性与可移植性）
*		                3、构建多层结构的系统
*		    
*	Date：2025
*	Version：0.1版本
*	Author：Coffee
*	Modify Recoder：
 ***/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace FacadePattern.CodeGenerationV1
{
    /// <summary>
    /// 定义一个子系统的外观对象，统一对外提供方法，外部不用关心与管理内部模块的实现
    /// </summary>
    internal class Facade
    {
        private Facade()
        {
            
        }

        /// <summary>
        /// 直接把客户端需要的功能单独定义一个方法提供出来
        /// </summary>
        public static void Generate()
        {
            //该方法实现的时候，可能会调用到内部的多个模块
            new Presentation().Generate();
            new Business().Generate();
            new DAO().Generate();
        }

    }//Class_end
}
